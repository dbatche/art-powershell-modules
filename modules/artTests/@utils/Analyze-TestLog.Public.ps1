function Analyze-TestLog {
    <#
    .SYNOPSIS
        Analyze test log files from Run-ApiTests-IRM.ps1
    
    .DESCRIPTION
        Post-processes JSON test logs to find patterns, errors, and issues.
        Supports filtering and custom validation logic.
    
    .PARAMETER LogFile
        Path to the JSON test log file generated by Run-ApiTests-IRM.ps1
    
    .PARAMETER ShowJsonErrors
        Show only tests with JSON validation errors
    
    .PARAMETER ShowFailures
        Show only failed tests (status mismatch)
    
    .PARAMETER ShowRequestBodies
        Show FULL request bodies (unlimited lines, default: 10 line preview)
    
    .PARAMETER ShowResponseBodies
        Show FULL response bodies (unlimited lines, default: 10 line preview)
    
    .PARAMETER FilterName
        Filter by test name (REGEX supported)
    
    .PARAMETER FilterMethod
        Filter by HTTP method
    
    .PARAMETER FilterStatus
        Filter by actual status code
    
    .PARAMETER FilterType
        Filter by test type (Contract, Functional, Manual, etc.)
    
    .PARAMETER OutputFormat
        Output format: 'Display' (default, detailed view), 'Table' (compact table), 'Object' (pipeable objects)
    
    .PARAMETER FormatTable
        Output as table (like test runner) - Deprecated: Use -OutputFormat Table instead
    
    .PARAMETER ContractFile
        Optional: Path to contract schema JSON file (from Analyze-OpenApiSchema -OutputFile).
        When provided, validates each response against the OpenAPI schema.
        Auto-checks 30-contract-schemas/ folder for filenames.
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -ShowJsonErrors
        # Show only tests with JSON validation errors
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -ShowFailures -FormatTable
        # Show failed tests in table format
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -FilterMethod POST -FilterStatus 201
        # Filter by POST methods with 201 status
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -FilterName "all fields"
        # Default: 10-line preview for both request and response
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -FilterName "all fields" -ShowRequestBodies
        # Show FULL request bodies (unlimited)
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -FilterName "all fields" -ShowResponseBodies
        # Show FULL response bodies (unlimited)
    
    .EXAMPLE
        Analyze-TestLog -LogFile test-results-*.json -ShowFailures -ShowRequestBodies -ShowResponseBodies
        # Show FULL request AND response bodies for failures
    
    .EXAMPLE
        Analyze-TestLog -LogFile "log.json" -ContractFile "contract.json"
        # Analyze results and validate responses against contract schema
    
    .EXAMPLE
        Analyze-TestLog -LogFile "log.json" -ContractFile "contract-POST-items.json" -ShowFailures
        # Show failures with contract compliance validation
    #>
    
    [CmdletBinding()]
    param(
        [Parameter(Mandatory=$true)]
        [string]$LogFile,
        
        [switch]$ShowJsonErrors,      # Show only tests with JSON validation errors
        [switch]$ShowFailures,        # Show only failed tests (status mismatch)
        [switch]$ShowRequestBodies,   # Show FULL request bodies (unlimited lines, default: 10 line preview)
        [switch]$ShowResponseBodies,  # Show FULL response bodies (unlimited lines, default: 10 line preview)
        [string]$FilterName,          # Filter by test name (REGEX supported)
        [string]$FilterMethod,        # Filter by HTTP method
        [int]$FilterStatus,           # Filter by actual status code
        [string]$FilterType,          # Filter by test type
        [ValidateSet('Display', 'Table', 'Object')]
        [string]$OutputFormat = 'Display',  # Output format
        [switch]$FormatTable,         # Output as table (deprecated - use OutputFormat)
        [string]$ContractFile         # Optional: Contract schema file for response validation
    )

    # Smart input path detection for LogFile
    $logPath = if (Test-Path $LogFile) {
        $LogFile
    } elseif ($LogFile -notmatch '[\\/]') {
        # Just a filename - try default folder
        $moduleRoot = $(if ($global:ArtTestsModuleRoot) { $global:ArtTestsModuleRoot } else { $PSScriptRoot })
        $defaultPath = Join-Path $moduleRoot "50-test-results" $LogFile
        if (Test-Path $defaultPath) {
            $defaultPath
        } else {
            throw "Log file not found: $LogFile (tried current dir and 50-test-results/)"
        }
    } else {
        if (-not (Test-Path $LogFile)) {
            throw "Log file not found: $LogFile"
        }
        $LogFile
    }
    
    Write-Host "Loading test log..." -ForegroundColor Cyan
    $log = Get-Content $logPath | ConvertFrom-Json

    # Load contract file if provided for compliance validation
    $contract = $null
    if ($ContractFile) {
        # Smart input path detection for ContractFile
        $contractPath = if (Test-Path $ContractFile) {
            $ContractFile
        } elseif ($ContractFile -notmatch '[\\/]') {
            # Just a filename - try default folder
            $moduleRoot = $(if ($global:ArtTestsModuleRoot) { $global:ArtTestsModuleRoot } else { $PSScriptRoot })
            $defaultPath = Join-Path $moduleRoot "30-contract-schemas" $ContractFile
            if (Test-Path $defaultPath) {
                $defaultPath
            } else {
                Write-Warning "Contract file not found: $ContractFile (tried current dir and 30-contract-schemas/). Compliance validation will be skipped."
                $ContractFile = $null
            }
        } else {
            if (-not (Test-Path $ContractFile)) {
                Write-Warning "Contract file not found: $ContractFile. Compliance validation will be skipped."
                $ContractFile = $null
            } else {
                $ContractFile
            }
        }
        
        if ($contractPath) {
            Write-Host "Loading contract schema for validation..." -ForegroundColor Cyan
            $contract = Get-Content $contractPath | ConvertFrom-Json
            
            # Load Test-ContractCompliance function
            $compliancePath = Join-Path $PSScriptRoot 'Test-ContractCompliance.Public.ps1'
            if (Test-Path $compliancePath) {
                . $compliancePath
                Write-Host "✓ Contract compliance validation enabled" -ForegroundColor Green
            } else {
                Write-Warning "Test-ContractCompliance.Public.ps1 not found. Compliance validation will be skipped."
                $contract = $null
            }
        }
    }

    Write-Host ""
    Write-Host ("=" * 100) -ForegroundColor Cyan
    Write-Host "TEST LOG ANALYSIS" -ForegroundColor Cyan
    Write-Host ("=" * 100) -ForegroundColor Cyan
    Write-Host ""
    Write-Host "Test Run Details:" -ForegroundColor Yellow
    Write-Host "  Timestamp: $($log.TestRun.Timestamp)" -ForegroundColor Gray
    Write-Host "  Base URL: $($log.TestRun.BaseUrl)" -ForegroundColor Gray
    
    # Show API version if available in log
    if ($log.TestRun.ApiVersion) {
        Write-Host "  API Version: $($log.TestRun.ApiVersion)" -ForegroundColor Yellow
        if ($log.TestRun.ApiDebug) {
            Write-Host "  Debug Mode: $($log.TestRun.ApiDebug)" -ForegroundColor Gray
        }
    }
    
    Write-Host "  Total Tests: $($log.TestRun.TotalTests)" -ForegroundColor Gray
    Write-Host "  Passed: $($log.TestRun.Passed)" -ForegroundColor Green
    Write-Host "  Failed: $($log.TestRun.Failed)" -ForegroundColor $(if($log.TestRun.Failed -gt 0){"Red"}else{"Green"})
    Write-Host ""

    # Apply filters
    $results = $log.Results

    if ($FilterName) {
        $results = $results | Where-Object { $_.Name -match $FilterName }
    }

    if ($FilterMethod) {
        $results = $results | Where-Object { $_.Method -eq $FilterMethod }
    }

    if ($FilterStatus) {
        $results = $results | Where-Object { $_.ActualStatus -eq $FilterStatus }
    }

    if ($FilterType) {
        $results = $results | Where-Object { $_.Type -eq $FilterType }
        Write-Host "Filtered to Type = '$FilterType'" -ForegroundColor Cyan
        Write-Host ""
    }

    if ($ShowJsonErrors) {
        $results = $results | Where-Object { $_.JsonValid -eq $false }
        Write-Host "Showing tests with JSON validation errors only" -ForegroundColor Yellow
        Write-Host ""
    }

    if ($ShowFailures) {
        $results = $results | Where-Object { $_.Result -eq '✘' }
        Write-Host "Showing failed tests only" -ForegroundColor Yellow
        Write-Host ""
    }

    # Handle backwards compatibility for FormatTable switch
    if ($FormatTable) {
        $OutputFormat = 'Table'
    }

    # Display results
    if ($OutputFormat -eq 'Table') {
        # Table format (like test runner)
        # Enhance results with computed properties
        $results | Select-Object `
            @{Name='Result'; Expression={
                # Consider both status match AND JSON validity
                $statusMatch = $_.ActualStatus -eq $_.ExpectedStatus
                $jsonOk = $_.JsonValid -ne $false  # null or true is ok
                if ($statusMatch -and $jsonOk) { '✔' } else { '✘' }
            }},
            Name,
            Method,
            ExpectedStatus,
            ActualStatus,
            Type,
            JsonValid,
            @{Name='ErrorOrPreview'; Expression={
                # Try to extract error code and description from API errors
                if ($_.ActualStatus -ge 400 -and $_.Body) {
                    try {
                        $errorBody = $_.Body | ConvertFrom-Json
                        if ($errorBody.errors -and $errorBody.errors.Count -gt 0) {
                            $err = $errorBody.errors[0]
                            "$($err.code) - $($err.description)"
                        } else {
                            $_.BodyPreview
                        }
                    } catch {
                        $_.BodyPreview
                    }
                } else {
                    $_.BodyPreview
                }
            }} | 
            Format-Table -AutoSize
    } elseif ($OutputFormat -eq 'Object') {
        # Object format - return pipeable objects
        return $results
    } else {
        # Detailed format (Display)
        foreach ($result in $results) {
            # Calculate overall result considering both status match and JSON validity
            $statusMatch = $result.ActualStatus -eq $result.ExpectedStatus
            $jsonOk = $result.JsonValid -ne $false  # null or true is ok
            $overallPass = $statusMatch -and $jsonOk
            $resultSymbol = if ($overallPass) { '✔' } else { '✘' }
            $resultColor = if ($overallPass) { "Green" } else { "Red" }
            
            Write-Host ("=" * 100) -ForegroundColor $resultColor
            Write-Host "$resultSymbol $($result.Name)" -ForegroundColor $resultColor
            Write-Host ("=" * 100) -ForegroundColor $resultColor
            
            Write-Host "  Method: $($result.Method)" -ForegroundColor Yellow
            Write-Host "  URL: $($result.Url)" -ForegroundColor Gray
            
            # Request body handling (consistent with response body)
            if ($result.RequestBody) {
                if ($ShowRequestBodies) {
                    Write-Host "  Request Body (FULL):" -ForegroundColor Cyan
                    try {
                        # Pretty-print with NO truncation
                        $prettyRequest = $result.RequestBody | ConvertFrom-Json | ConvertTo-Json -Depth 10
                        $requestLines = $prettyRequest -split "`n"
                        foreach ($line in $requestLines) {
                            Write-Host "    $line" -ForegroundColor Gray
                        }
                    } catch {
                        # If JSON parsing fails, show raw (could be long!)
                        Write-Host "    $($result.RequestBody)" -ForegroundColor Gray
                    }
                } else {
                    Write-Host "  Request Body Preview (10 lines):" -ForegroundColor Cyan
                    try {
                        # Pretty-print with 10 line limit
                        $prettyRequest = $result.RequestBody | ConvertFrom-Json | ConvertTo-Json -Depth 10
                        $requestLines = $prettyRequest -split "`n" | Select-Object -First 10
                        foreach ($line in $requestLines) {
                            Write-Host "    $line" -ForegroundColor Gray
                        }
                        if (($prettyRequest -split "`n").Count -gt 10) {
                            Write-Host "    ... (truncated, use -ShowRequestBodies for full)" -ForegroundColor DarkGray
                        }
                    } catch {
                        # If JSON parsing fails, show preview
                        Write-Host "    $($result.RequestBody)" -ForegroundColor Gray
                    }
                }
            }
            
            # Color expected status: green for 2xx, red for 4xx
            $expectedColor = if ($result.ExpectedStatus -ge 200 -and $result.ExpectedStatus -lt 300) { "Green" } else { "Red" }
            Write-Host "  Expected Status: $($result.ExpectedStatus)" -ForegroundColor $expectedColor
            
            # Color actual status: green for 2xx, red for 4xx, purple for 5xx
            $actualColor = if ($result.ActualStatus -ge 500) { 
                "Magenta" 
            } elseif ($result.ActualStatus -ge 400) { 
                "Red" 
            } elseif ($result.ActualStatus -ge 200 -and $result.ActualStatus -lt 300) { 
                "Green" 
            } else { 
                "Yellow" 
            }
            Write-Host "  Actual Status: $($result.ActualStatus)" -ForegroundColor $actualColor
            
            if ($null -ne $result.JsonValid) {
                $jsonColor = if($result.JsonValid -eq $true){"Green"}elseif($result.JsonValid -eq $false){"Red"}else{"Gray"}
                Write-Host "  JSON Valid: $($result.JsonValid)" -ForegroundColor $jsonColor
                
                if ($result.JsonError) {
                    Write-Host "  JSON Error: $($result.JsonError)" -ForegroundColor Red
                }
            }
            
            if ($result.ResponseError) {
                Write-Host "  Response Error: $($result.ResponseError)" -ForegroundColor Red
            }
            
            # Response body handling
            if ($ShowResponseBodies -and $result.Body) {
                Write-Host ""
                Write-Host "  Response Body (FULL):" -ForegroundColor Cyan
                try {
                    # Pretty-print with NO truncation
                    $prettyResponse = $result.Body | ConvertFrom-Json | ConvertTo-Json -Depth 10
                    $responseLines = $prettyResponse -split "`n"
                    foreach ($line in $responseLines) {
                        Write-Host "    $line" -ForegroundColor Gray
                    }
                } catch {
                    # If JSON parsing fails, show raw (could be long!)
                    Write-Host "    $($result.Body)" -ForegroundColor Gray
                }
            } else {
                Write-Host ""
                Write-Host "  Response Preview (10 lines):" -ForegroundColor Cyan
                try {
                    # Try to pretty-print with 10 line limit
                    $prettyBody = $result.Body | ConvertFrom-Json | ConvertTo-Json -Depth 10
                    $bodyLines = $prettyBody -split "`n" | Select-Object -First 10
                    foreach ($line in $bodyLines) {
                        Write-Host "    $line" -ForegroundColor Gray
                    }
                    if (($prettyBody -split "`n").Count -gt 10) {
                        Write-Host "    ... (truncated, use -ShowResponseBodies for full)" -ForegroundColor DarkGray
                    }
                } catch {
                    # If JSON parsing fails, show preview (one-liner)
                    Write-Host "    $($result.BodyPreview)" -ForegroundColor Gray
                    Write-Host "    (Invalid JSON, use -ShowResponseBodies to see raw)" -ForegroundColor DarkGray
                }
            }
            
            # Contract compliance validation (if contract provided)
            if ($contract -and $result.Body) {
                try {
                    # Parse response
                    $response = $result.Body | ConvertFrom-Json
                    
                    # Get schema for this status code
                    $statusCode = $result.ActualStatus.ToString()
                    $responseSchema = $contract.ResponseSchemas.$statusCode
                    
                    if ($responseSchema) {
                        # Helper: Convert PSCustomObject to hashtable recursively
                        function ConvertTo-Hashtable {
                            param([object]$InputObject)
                            
                            if ($InputObject -is [PSCustomObject]) {
                                $hash = @{}
                                $InputObject.PSObject.Properties | ForEach-Object {
                                    $hash[$_.Name] = if ($_.Value -is [PSCustomObject]) {
                                        ConvertTo-Hashtable $_.Value
                                    } else {
                                        $_.Value
                                    }
                                }
                                return $hash
                            } elseif ($InputObject -is [hashtable]) {
                                return $InputObject
                            } else {
                                return $InputObject
                            }
                        }
                        
                        # Convert schema properties to hashtable
                        $schemaHash = @{}
                        if ($responseSchema.Properties) {
                            if ($responseSchema.Properties -is [PSCustomObject]) {
                                $responseSchema.Properties.PSObject.Properties | ForEach-Object {
                                    $schemaHash[$_.Name] = ConvertTo-Hashtable $_.Value
                                }
                            } elseif ($responseSchema.Properties -is [hashtable]) {
                                $schemaHash = $responseSchema.Properties
                            }
                        }
                        
                        # Validate response against schema
                        $validation = Test-ContractCompliance -Response $response -Schema $schemaHash -ShowDetails:$false
                        
                        Write-Host ""
                        $complianceLabel = if ($statusCode -ge 400) { 
                            "Error Response Compliance" 
                        } else { 
                            "Contract Compliance" 
                        }
                        
                        if ($validation.IsValid) {
                            Write-Host "  $complianceLabel`: ✅ VALID" -ForegroundColor Green
                            Write-Host "    $($validation.Summary)" -ForegroundColor Gray
                        } else {
                            Write-Host "  $complianceLabel`: ❌ INVALID" -ForegroundColor Red
                            Write-Host "    $($validation.Summary)" -ForegroundColor Gray
                            
                            # Show errors
                            if ($validation.Errors.Count -gt 0 -and $validation.Errors.Count -le 5) {
                                foreach ($validationError in $validation.Errors) {
                                    Write-Host "    ❌ $validationError" -ForegroundColor Red
                                }
                            } elseif ($validation.Errors.Count -gt 5) {
                                foreach ($validationError in $validation.Errors | Select-Object -First 5) {
                                    Write-Host "    ❌ $validationError" -ForegroundColor Red
                                }
                                Write-Host "    ... and $($validation.Errors.Count - 5) more errors" -ForegroundColor DarkRed
                            }
                            
                            # Show warnings
                            if ($validation.Warnings.Count -gt 0 -and $validation.Warnings.Count -le 3) {
                                foreach ($warning in $validation.Warnings) {
                                    Write-Host "    ⚠ $warning" -ForegroundColor Yellow
                                }
                            }
                        }
                    } else {
                        Write-Host ""
                        Write-Host "  Contract Compliance: ⚠ No schema defined for status $statusCode" -ForegroundColor Yellow
                    }
                } catch {
                    Write-Host ""
                    Write-Host "  Contract Compliance: ⚠ Cannot validate (JSON parse error)" -ForegroundColor Yellow
                }
            }
            
            Write-Host ""
        }
    }

    # Summary statistics
    Write-Host ("=" * 100) -ForegroundColor Cyan
    Write-Host "SUMMARY STATISTICS" -ForegroundColor Cyan
    Write-Host ("=" * 100) -ForegroundColor Cyan
    Write-Host ""

    $jsonInvalidCount = ($log.Results | Where-Object { $_.JsonValid -eq $false }).Count
    if ($jsonInvalidCount -gt 0) {
        Write-Host "⚠ JSON Validation Issues: $jsonInvalidCount" -ForegroundColor Red
        $jsonErrorTests = $log.Results | Where-Object { $_.JsonValid -eq $false } | Select-Object -ExpandProperty Name
        foreach ($test in $jsonErrorTests) {
            Write-Host "  • $test" -ForegroundColor Yellow
        }
        Write-Host ""
    }

    Write-Host "Status Code Distribution:" -ForegroundColor Yellow
    $log.Results | Group-Object ActualStatus | 
        Sort-Object Name | 
        ForEach-Object { 
            $color = if($_.Name -ge 400){"Red"}elseif($_.Name -ge 200 -and $_.Name -lt 300){"Green"}else{"Yellow"}
            Write-Host "  $($_.Name): $($_.Count) tests" -ForegroundColor $color 
        }

    Write-Host ""
    Write-Host "Method Distribution:" -ForegroundColor Yellow
    $log.Results | Group-Object Method | 
        Sort-Object Name | 
        ForEach-Object { Write-Host "  $($_.Name): $($_.Count) tests" -ForegroundColor Gray }

    Write-Host ""
    Write-Host "Filtered Results: $($results.Count) tests" -ForegroundColor Cyan
}

